#include <iostream>
#include <random>
#include <fstream>
#include <filesystem>
#include <sodium.h>
#include <readline/readline.h>
#include <format>
#include "../encryption/encryptDecrypt.hpp"
#include "../utils/utils.hpp"
#include "passwords.hpp"

namespace fs = std::filesystem;

/**
 * @brief Checks the strength of a password.
 * @param password the password to process.
 * @return True if the password is strong, False otherwise.
 */
bool isPasswordStrong(const std::string &password) noexcept {
    // Check the length
    if (password.length() < 8) {
        return false;
    }

    // Check for at least one uppercase letter, one lowercase letter, one digit, and one special character.
    bool hasUppercase = false;
    bool hasLowercase = false;
    bool hasDigit = false;
    bool hasPunctuation = false;

    for (char ch: password) {
        if (std::isupper(ch))
            hasUppercase = true;
        else if (std::islower(ch))
            hasLowercase = true;
        else if (std::isdigit(ch))
            hasDigit = true;
        else if (std::ispunct(ch))
            hasPunctuation = true;

        // Break out of the loop as soon as all conditions are satisfied
        if (hasUppercase && hasLowercase && hasDigit && hasPunctuation)
            return true;
    }

    return false;
}

/**
 * @brief Generates a random password.
 * @param length the length of the password.
 * @return a random password.
 */
std::string generatePassword(int length) {
    // a password shouldn't be too short, nor too long
    if (length < 8)
        throw std::length_error("Password too short.");
    if (length > 256)
        throw std::length_error("Password too long.");

    // generate from a set of printable ascii characters
    const std::string characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-=_~+[]{}<>";

    // Seed the Mersenne Twister engine with a random source (ideally non-deterministic)
    std::random_device rd;
    std::mt19937_64 generator(rd());

    // Constant probability minimizes predictability
    std::uniform_int_distribution<int> distribution(0, static_cast<int>(characters.size()) - 1);

    std::string password;
    password.reserve(length);

    // Generate a strong password by default
    do {
        password.clear();  // reset the password
        for (int i = 0; i < length; ++i)
            password += characters[distribution(generator)];
    } while (!isPasswordStrong(password));

    return password;
}

/**
 * @brief Hashes a password (using Argon2id implementation from Sodium)
 * for verification without having to store the password.
 * @param password the password to hash.
 * @param opsLimit the maximum amount of computations to perform.
 * @param memLimit the maximum amount of RAM in bytes that the function will use.
 * @return a string of the password hash and it's associated data.
 */
std::string hashPassword(const std::string &password, const std::size_t &opsLimit, const std::size_t &memLimit) {
    char hashedPassword[crypto_pwhash_STRBYTES];

    if (crypto_pwhash_str
                (hashedPassword, password.c_str(), password.size(),
                 opsLimit, memLimit) != 0) {
        throw std::runtime_error("Out of memory for password hashing.");
    }

    return std::string{hashedPassword};
}

/**
 * @brief Verifies a password.
 * @param password the password being verified.
 * @param storedHash the hash to verify the password against.
 * @return true if the verification succeeds, else false.
 */
bool verifyPassword(const std::string &password, const std::string &storedHash) {
    return crypto_pwhash_str_verify(storedHash.c_str(),
                                    password.c_str(),
                                    password.size()) == 0;
}


/**
 * @brief Encrypts and then saves passwords to a file.
 * @param passwords a vector of password records.
 * @param filePath the path where the file is saved.
 * @param encryptionKey the key/password to encrypt the passwords in the process.
 * @return True, if successful.
 */
bool savePasswords(const std::vector<passwordRecords> &passwords, const std::string &filePath, const std::string &encryptionKey) {
    std::ofstream file(filePath);
    if (!file) {
        std::cerr << std::format("Failed to open the password file ({}) for writing.\n", filePath);
        return false;
    }

    file << "PLEASE DO NOT EDIT THIS FILE" << std::endl;
    file << hashPassword(encryptionKey) << std::endl;

    for (const auto &password: passwords) {
        std::string encryptedPassword = encryptString(std::get<2>(password), encryptionKey);

        if (encryptedPassword.empty()) {
            std::cerr << std::format("Failed to encrypt password for {}", std::get<0>(password)) << std::endl;
            return false;
        }

        file << std::get<0>(password) << ":" << std::get<1>(password) << ":" << encryptedPassword << std::endl;
    }
    file.close();

    return true;
}

/**
 * @brief Loads the encrypted passwords from the disk, and decrypts them.
 * @param filePath path to the password file.
 * @param decryptionKey the key/password to decrypt the passwords.
 * @return decrypted password records.
 */
std::vector<passwordRecords> loadPasswords(const std::string &filePath, const std::string &decryptionKey) {
    std::vector<passwordRecords> passwords;

    std::error_code ec;
    if (!std::filesystem::exists(filePath, ec)) {
        throw std::runtime_error(std::format("The password file ({}) does not exist.\n", filePath));
    }

    if (ec) {
        std::cerr << ec.message() << std::endl;
    }

    std::ifstream file(filePath);
    if (!file)
        throw std::runtime_error("Failed to open the password file for reading.");

    std::string line;
    std::getline(file, line); // Read and discard the first line
    std::getline(file, line); // Read and discard the second line too

    while (std::getline(file, line)) {
        std::size_t firstDelimiterPos = line.find(':');
        std::size_t secondDelimiterPos = line.find(':', firstDelimiterPos + 1);

        // TODO: Limit how many characters are read for security reasons.

        if (firstDelimiterPos == std::string::npos || secondDelimiterPos == std::string::npos) {
            std::cerr << std::format("Invalid password entry: {}\n", line);
            continue;
        }

        std::string website = line.substr(0, firstDelimiterPos);
        std::string username = line.substr(firstDelimiterPos + 1, secondDelimiterPos - firstDelimiterPos - 1);

        std::string encryptedPassword = line.substr(secondDelimiterPos + 1);
        std::string decryptedPassword = decryptString(encryptedPassword, decryptionKey);

        if (decryptedPassword.empty()) {
            std::cerr << std::format("Failed to decrypt password for {}\n", website);
            continue;
        }

        passwords.emplace_back(website, username, decryptedPassword);
    }

    return passwords;
}

/**
 * @brief Helps the user change the primary password.
 * @param masterPassword the current primary password.
 * @return True if the password is changed successfully, else false.
 */
bool changeMasterPassword(std::string &masterPassword) {
    std::string oldPassword = getSensitiveInfo("Enter the current master password: ");
    sodium_mlock(oldPassword.data(), oldPassword.size());

    std::string masterHash = hashPassword(masterPassword, crypto_pwhash_OPSLIMIT_INTERACTIVE,
                                     crypto_pwhash_MEMLIMIT_INTERACTIVE);

    if (!verifyPassword(oldPassword, masterHash)) {
        sodium_munlock(oldPassword.data(), oldPassword.size());
        std::cerr << "Password verification failed." << std::endl;
        return false;
    }
    sodium_munlock(oldPassword.data(), oldPassword.size());

    std::string newPassword = getSensitiveInfo("Enter the new master password: ");
    sodium_mlock(newPassword.data(), newPassword.size());

    std::string newPassword2 = getSensitiveInfo("Enter the new master password again: ");
    sodium_mlock(newPassword2.data(), newPassword2.size());
    // Verify that the new password is correct
    if (!verifyPassword(newPassword2, hashPassword(newPassword, crypto_pwhash_OPSLIMIT_INTERACTIVE,
                                                   crypto_pwhash_MEMLIMIT_INTERACTIVE))) {
        sodium_munlock(newPassword.data(), newPassword.size());
        sodium_munlock(newPassword2.data(), newPassword2.size());
        std::cerr << "Passwords do not match." << std::endl;

        return false;
    }
    sodium_munlock(newPassword2.data(), newPassword2.size());
    masterPassword = newPassword;

    sodium_munlock(newPassword.data(), newPassword.size());

    return true;
}

/**
 * @brief Helps with the initial setup of the password manager.
 * @return New primary password and/or path to the password file, whichever is applicable.
 */
std::pair<std::string, std::string> initialSetup() noexcept {
    std::pair<std::string, std::string> ret{"", ""}; // ret.first = path to file, ret.second = new primary password

    std::cout << "Looks like you don't have any passwords saved yet." << std::endl;

    while (true) {

        int resp = getResponseInt(
                "1. Initial setup. (Select if you haven't used this program to manage credentials before).\n"
                "2. Enter the path to an existing password file (previously created by this program).\n"
                "3. Exit.\n"
                "select 1, 2, or 3: ");
        if (resp == 1) {
            std::string pass = getSensitiveInfo("Enter a new master password: ");

            int count{0};
            while (!isPasswordStrong(pass) && count < 2) {
                std::cerr
                        << "Weak password! Password should have at least 8 characters and include uppercase letters,\n"
                           "lowercase letters, special characters and digits" << std::endl;
                pass = getSensitiveInfo("Please enter a stronger password: ");
                ++count;
            }

            if (count == 2) {
                std::cerr << "\n3 incorrect password attempts." << std::endl;
                continue;
            }

            std::string hash = hashPassword(pass, crypto_pwhash_OPSLIMIT_INTERACTIVE, crypto_pwhash_MEMLIMIT_INTERACTIVE);
            std::string pass2 = getSensitiveInfo("Enter the password again: ");

            if (!verifyPassword(pass2, hash)) {
                std::cerr << "Password mismatch!" << std::endl;
                continue;
            }

            ret.second = pass;
            break;
        } else if (resp == 2) {
            std::string path = getResponseStr("Enter the path to the file: ");
            if (!(fs::exists(path) && fs::is_regular_file(path))) {
                std::cerr << "That file doesn't exist or is not a regular file." << std::endl;
                continue;
            }

            ret.first = path;
            break;

        } else if (resp == 3) {
            return ret;
        } else {
            std::cerr << "Invalid choice. Try again" << std::endl;
            continue;
        }
    }
    return ret;
}

/**
 * @brief Reads the primary password hash from the password records.
 * @param filePath the path to the file containing the password records (the password file).
 * @return the primary password hash.
 */
std::string getHash(const std::string &filePath) {
    if (fs::is_empty(filePath))
        [[unlikely]]
                std::cerr << "The password file seems empty. Trying to read it regardless..." << std::endl;

    std::ifstream passFileStream(filePath);

    if (!passFileStream)
        throw std::runtime_error("Failed to open the password file for reading.");

    std::string pwHash;
    std::getline(passFileStream, pwHash); // Read and discard the first line
    std::getline(passFileStream, pwHash);
    passFileStream.close();

    if (pwHash.empty())
        throw std::runtime_error("The password file is empty.");

    if (!pwHash.contains("argon"))
        throw std::runtime_error("Invalid password hash in the password file.");

    return pwHash;
}
