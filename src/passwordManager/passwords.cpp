#include <iostream>
#include <random>
#include <fstream>
#include <filesystem>
#include <sodium.h>
#include <readline/readline.h>
#include <format>
#include "../encryption/encryptDecrypt.hpp"
#include "../utils/utils.hpp"
#include "passwords.hpp"

namespace fs = std::filesystem;

/**
 * @brief Checks the strength of a password.
 * @param password the password to process.
 * @return True if the password is strong, False otherwise.
 */
bool isPasswordStrong(const std::string &password) noexcept {
    // Check the length
    if (password.length() < 8) {
        return false;
    }

    // Check for at least one uppercase letter, one lowercase letter, one digit, and one special character.
    bool hasUppercase = false;
    bool hasLowercase = false;
    bool hasDigit = false;
    bool hasPunctuation = false;

    for (char ch: password) {
        if (std::isupper(ch))
            hasUppercase = true;
        else if (std::islower(ch))
            hasLowercase = true;
        else if (std::isdigit(ch))
            hasDigit = true;
        else if (std::ispunct(ch))
            hasPunctuation = true;

        // Break out of the loop as soon as all conditions are satisfied
        if (hasUppercase && hasLowercase && hasDigit && hasPunctuation)
            return true;
    }

    return false;
}

/**
 * @brief Generates a random password.
 * @param length the length of the password.
 * @return a random password.
 */
std::string generatePassword(int length) {
    // a password shouldn't be too short, nor too long
    if (length < 8)
        throw std::length_error("Password too short.");
    if (length > 256)
        throw std::length_error("Password too long.");

    // generate from a set of printable ascii characters
    const std::string characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-=_~+[]{}<>";

    // Seed the Mersenne Twister engine with a random source (ideally non-deterministic)
    std::random_device rd;
    std::mt19937_64 generator(rd());

    // Constant probability minimizes predictability
    std::uniform_int_distribution<int> distribution(0, static_cast<int>(characters.size()) - 1);

    std::string password;
    password.reserve(length);

    // Generate a strong password by default
    do {
        password.clear();  // reset the password
        for (int i = 0; i < length; ++i)
            password += characters[distribution(generator)];
    } while (!isPasswordStrong(password));

    return password;
}

/**
 * @brief Hashes a password (using Argon2id implementation from Sodium)
 * for verification without having to store the password.
 * @param password the password to hash.
 * @param opsLimit the maximum amount of computations to perform.
 * @param memLimit the maximum amount of RAM in bytes that the function will use.
 * @return a string of the password hash and it's associated data.
 */
std::string hashPassword(const std::string &password, const std::size_t &opsLimit, const std::size_t &memLimit) {
    char hashedPassword[crypto_pwhash_STRBYTES];

    if (crypto_pwhash_str
                (hashedPassword, password.c_str(), password.size(),
                 opsLimit, memLimit) != 0) {
        throw std::runtime_error("Out of memory for password hashing.");
    }

    return std::string{hashedPassword};
}

/**
 * @brief Verifies a password.
 * @param password the password being verified.
 * @param storedHash the hash to verify the password against.
 * @return true if the verification succeeds, else false.
 */
bool verifyPassword(const std::string &password, const std::string &storedHash) {
    return crypto_pwhash_str_verify(storedHash.c_str(),
                                    password.c_str(),
                                    password.size()) == 0;
}


/**
 * @brief Encrypts and then saves passwords to a file.
 * @param passwords a vector of password records.
 * @param filePath the path where the file is saved.
 * @param encryptionKey the key/password to encrypt the passwords in the process.
 * @return True, if successful.
 */
bool savePasswords(const std::vector<passwordRecords> &passwords, const std::string &filePath, const std::string &encryptionKey) {
    std::ofstream file(filePath);
    if (!file) {
        std::cerr << std::format("Failed to open the password file ({}) for writing.\n", filePath);
        return false;
    }

    file << "PLEASE DO NOT EDIT THIS FILE" << std::endl;
    file << hashPassword(encryptionKey) << std::endl;

    for (const auto &password: passwords) {
        std::string encryptedPassword = encryptString(std::get<2>(password), encryptionKey);

        if (encryptedPassword.empty()) {
            std::cerr << std::format("Failed to encrypt password for {}", std::get<0>(password)) << std::endl;
            return false;
        }

        file << std::get<0>(password) << ":" << std::get<1>(password) << ":" << encryptedPassword << std::endl;
    }
    file.close();

    return true;
}

/**
 * @brief Loads the encrypted passwords from the disk, and decrypts them.
 * @param filePath path to the password file.
 * @param decryptionKey the key/password to decrypt the passwords.
 * @return decrypted password records.
 */
std::vector<passwordRecords> loadPasswords(const std::string &filePath, const std::string &decryptionKey) {
    std::vector<passwordRecords> passwords;

    std::error_code ec;
    if (!std::filesystem::exists(filePath, ec)) {
        throw std::runtime_error(std::format("The password file ({}) does not exist.\n", filePath));
    }

    if (ec) {
        std::cerr << ec.message() << std::endl;
    }

    std::ifstream file(filePath);
    if (!file)
        throw std::runtime_error("Failed to open the password file for reading.");

    std::string line;
    std::getline(file, line); // Read and discard the first line
    std::getline(file, line); // Read and discard the second line too

    while (std::getline(file, line)) {
        std::size_t firstDelimiterPos = line.find(':');
        std::size_t secondDelimiterPos = line.find(':', firstDelimiterPos + 1);

        // TODO: Limit how many characters are read for security reasons.

        if (firstDelimiterPos == std::string::npos || secondDelimiterPos == std::string::npos) {
            std::cerr << std::format("Invalid password entry: {}\n", line);
            continue;
        }

        std::string website = line.substr(0, firstDelimiterPos);
        std::string username = line.substr(firstDelimiterPos + 1, secondDelimiterPos - firstDelimiterPos - 1);

        std::string encryptedPassword = line.substr(secondDelimiterPos + 1);
        std::string decryptedPassword = decryptString(encryptedPassword, decryptionKey);

        if (decryptedPassword.empty()) {
            std::cerr << std::format("Failed to decrypt password for {}\n", website);
            continue;
        }

        passwords.emplace_back(website, username, decryptedPassword);
    }

    return passwords;
}
